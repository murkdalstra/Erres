# Import necessary libraries
import RPi.GPIO as GPIO
import time, datetime
import math
import subprocess
from socketIO_client import SocketIO, LoggingNamespace

# Variable declaration
global knop_pinout, knop_status, LED_pin
global playerstatus, connected, apiHost, apiPort, station
global volumeDial, tuneDial, volumioVolume

# START - INITIALIZATION

# Configure the Pi to use the BCM (Broadcom) pin names, rather than the pin pos$
GPIO.setmode(GPIO.BOARD)

knop_pinout = [8, 32, 36, 13, 11, 15]
knop_status = [1, 1, 1, 1, 1, 1]
old_knop_status = [1, 1, 1, 1, 1, 1]
LED_pin = 10

print("Initialisatie GPIOs")
for x in knop_pinout:
            GPIO.setup(x, GPIO.IN, pull_up_down=GPIO.PUD_UP)
            print("Kanaal " + str(x) + ": " +  str(GPIO.input(x)))

# Set pin for LED
GPIO.setup(LED_pin, GPIO.OUT)

# Configure the socket connection and connect
apiHost = 'localhost'
apiPort = '3000'
connected = False
playerstatus = 'pause'

while connected == False:
    connected = True
    try:
        socketIO = SocketIO(apiHost, apiPort)
    except Exception as e:
        connected = False
    if connected == False:
        print "Verbinding mislukt. Nieuwe poging ..."
        time.sleep(5)
print("Verbonden")

# Configure the read out of analog inputs
# Condensator en weerstand waarde voor berekening potmeter weerstand tbv volume en afstemming
C = 0.33 # uF
R1 = 1000 # Ohms

# Pin a charges the capacitor through a fixed 1k resistor and the thermistor in$
# pin b discharges the capacitor through a fixed 1k resistor 
volume_a_pin = 33
volume_b_pin = 37
tune_a_pin = 31
tune_b_pin = 29

# END - INITIALIZATION

# START - SUBPROCESS DEFINITION

# verandering van knop 1 afhandelen
# knop 1: AAN / UIT
def knop_1(newstate):
    if newstate == 0:
        socketIO.emit('play')
        print(str(datetime.datetime.now()) + " Radio aan")    
    else:
        socketIO.emit('stop')
        print(str(datetime.datetime.now()) + " Radio uit")    

# verandering van knop 2 afhandelen
# knop 2: Radio / Spotify mode
def knop_2(newstate):
    if newstate == 1:
        print(str(datetime.datetime.now()) + " Radio mode")
        socketIO.emit('unmute')
    elif newstate == 2:
        print(str(datetime.datetime.now()) + " Spotify mode")
        socketIO.emit('mute')
    else:
        print(str(datetime.datetime.now()) + " Stand knop 2 onbekend")

# verandering van knop 3 afhandelen
# knop 3 - Zenderkeuze
def knop_3(newstate):
    if newstate == 1:
        print(str(datetime.datetime.now()) + " Zendergroep 1")
        socketIO.emit('replaceAndPlay', {'uri': 'http://icecast.omroep.nl/radio1-bb-mp3','title': 'NPO Radio1','service': 'webradio'})
    elif newstate == 2:
        print(str(datetime.datetime.now()) + " Zendergroep 2")
        socketIO.emit('replaceAndPlay', {'uri': 'http://icecast.omroep.nl/radio2-bb-mp3','title': 'NPO Radio1','service': 'webradio'})
    elif newstate == 3:
        print(str(datetime.datetime.now()) + " Zendergroep 3")
        socketIO.emit('replaceAndPlay', {'uri': 'http://icecast.omroep.nl/3fm-bb-mp3','title': 'NPO Radio1','service': 'webradio'})       
    else:
        print(str(datetime.datetime.now()) + " Stand knop 3 onbekend")

# empty the capacitor ready to start filling it up
def discharge(a_pin, b_pin):
    GPIO.setup(a_pin, GPIO.IN)
    GPIO.setup(b_pin, GPIO.OUT)
    GPIO.output(b_pin, False)
    time.sleep(0.01)
    
# return the time taken (uS) for the voltage on the capacitor to count as HIGH
# than means around 1.65V
def charge_time(a_pin, b_pin):
    GPIO.setup(b_pin, GPIO.IN)
    GPIO.setup(a_pin, GPIO.OUT)
    GPIO.output(a_pin, True)
    t1 = time.time()
    while not GPIO.input(b_pin):
        pass
    t2 = time.time()
    return (t2 - t1) * 1000000

# Take an analog reading as the time taken to charge after first discharging th$
def analog_read(a_pin, b_pin):
    discharge(a_pin, b_pin)
    t = charge_time(a_pin, b_pin)
    discharge(a_pin, b_pin)
    return t
    
# To reduce errors, do it n times and take the average.
def read_resistance(a_pin, b_pin):
    n = 40
    total = 0
    for i in range(1, n):
        total = total + analog_read(a_pin, b_pin)
    t = total / float(n)
    T = t * 0.632 * 3.3
    r = (T / C) - R1
    return r

def on_push_state(*args):
        #print('state', args)
        playerstatus = args[0]['status'].encode('ascii', 'ignore')
        print(str(datetime.datetime.now()) + " Player status: " + playerstatus)

socketIO.on('pushState', on_push_state)

# get initial state
socketIO.emit('getState', '', on_push_state)

# END - SUBPROCESS DEFINITION

# START - PROGRAM LOOP
try:
    while True:
        # Ieder cyclus de knopstatus inlezen
        # Oude status onthouden om verandering te bepalen
                
        y = 0
        for x in knop_pinout:
            old_knop_status[y] = knop_status[y]
            knop_status[y] = GPIO.input(x)
            #print("Pin " + str(x) + ": " + str(knop_status[y]) + "," + str(old_knop_status[y]))
            y = y + 1
        
        # Knop 1 - AAN / UIT
        if (not knop_status[0] == old_knop_status[0]):
            knop_1(knop_status[0])
        
        # Knop 2 - Radio / Spotify keuze
        if (not knop_status[1] == old_knop_status[1]) or (not knop_status[2] == old_knop_status[2]):
            if knop_status[1] == 0:
                knop_2(1)
            elif knop_status[2] == 0:
                knop_2(2)
            else:
                knop_2(0)
                
        # Knop 3 - Zenderkeuze
        if knop_status[3] <> old_knop_status[3] or knop_status[4] <> old_knop_status[4] or knop_status[5] <> old_knop_status[5]:
            if knop_status[3] == 0:
                knop_3(1)
            elif knop_status[4] == 0:
                knop_3(2)
            elif knop_status[5] == 0:
                knop_3(3)
            else:
                knop_3(0)
        
        # Knop 4 - Volume
        volumeDial = int(round(read_resistance(volume_a_pin, volume_b_pin)))
        volumioVolume = round(50*(volumeDial + 200)/750)
        if volumioVolume < 0 or knop_status[2] == 0:
            volumioVolume = 0
        elif volumioVolume > 50:
            volumioVolume = 50
        
        #print("Volume knop: " + str(volumeDial))
        #print("Volume nivo: " + str(volumioVolume))
       
        if knop_status[1] == 0:
            socketIO.emit('volume', volumioVolume)
        
        # Knop 5 - Afstemming
        tuneDial = round(100 * ((read_resistance(tune_a_pin, tune_b_pin) + 160) / 8000.0))
        #print("Afstemmingsknop: "+ str(tuneDial))
        
        # LED
        if playerstatus == 'stop':
            GPIO.output(LED_pin, False)
        elif playerstatus == 'play':
            GPIO.output(LED_pin, True)
        elif playerstatus == 'mute' or playerstatus == 'pause':
            if GPIO.input(LED_pin):
                GPIO.output(LED_pin, False)
            else:
                GPIO.output(LED_pin, True)
        
        socketIO.wait(1)
        time.sleep(1)
except Exception as e:
    f = open('Erres_Exception.log','a')
    f.write(str(datetime.datetime.now()) + " " + str(e))
    f.close()
    print(e)
except KeyboardInterrupt:
    f = open('Erres_Exception.log','a')
    f.write(str(datetime.datetime.now()) + " Gestopt door gebruiker")
    f.close()
    raise
finally:  
    print("Cleaning up GPIO")
    GPIO.cleanup()